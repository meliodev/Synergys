import { setToast } from "../core/utils"
import firebase from '@react-native-firebase/app'
import AsyncStorage from '@react-native-async-storage/async-storage'
import { onUploadProgressStart, onUploadProgressChange, onUploadProgressEnd } from '../core/redux'
import RNFS from 'react-native-fs'

const db = firebase.firestore()

export async function uploadFiles(files, storageRef, attachedFiles, isChat, chatId) {
    const promises = []
    let urls = [] //in case of failure

    for (let i = 0; i < files.length; i++) {

        const fileRef = storageRef.child(files[i].name)
        const uploadTask = fileRef.putFile(files[i].path)
        console.log(uploadTask)
        promises.push(uploadTask)

        // if (isChat) { //to cancel/pause/resume task
        //     files[i].uploadTask = uploadTask
        //     this.setState({ files })
        // }


        //     uploadTask.on('state_changed', function (snapshot) {
        //         var progress = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100)
        //         console.log('Upload file ' + i + ': ' + progress + '% done')
        //         if (!isChat) {
        //             files[i].progress = progress / 100
        //             this.setState({ files })
        //         }
        //     }.bind(this))

        //     uploadTask.then(async (result) => {
        //         console.log('result', result)
        //         const url = await storageRef.child(files[i].name).getDownloadURL()
        //         urls.push(url)
        //     })
    }

    // return Promise.all(promises)
    //     .then(async (results) => {

    //         //Build output files
    //         for (let i = 0; i < results.length; i++) {
    //             const downloadURL = await storageRef.child(files[i].name).getDownloadURL()
    //             const { name, size, contentType } = results[i].metadata
    //             const attachedFile = { downloadURL, name, size, contentType }

    //             if (isChat) {
    //                 attachedFile.messageId = files[i].messageId
    //                 //attachedFile.uploadTask =  files[i].uploadTask
    //             }

    //             attachedFiles.push(attachedFile)
    //         }

    //         this.setState({ attachedFiles })
    //         return true
    //     })
    //     .catch(async err => {
    //         console.error(err)
    //         if (this.isEdit)
    //             this.title = 'Modifier le projet'
    //         else
    //             this.title = 'Nouveau projet'

    //         setToast(this, 'e', 'Erreur lors du téléchargement des fichiers, veuillez réessayer.')

    //         //Delete uploaded files (in this case not all files were uploaded)
    //         for (let i = 0; i < urls.length; i++) {
    //             //Delete files from Firebase storage
    //             firebase.storage().refFromURL(urls[i]).delete()

    //             //Delete failed messages
    //             if (isChat) {
    //                 await db.collection('Chats').doc(chatId).collection('Messages').doc(attachedFiles[i].messageId).delete() //#task: set status to uploadFailed to allow user to retry
    //                 // await db.collection('Chats').doc(chatId).set(latestMsg, { merge: true }) //#task: keep previous last message to be able to restore it
    //                 this.setState({ imageSource: '', videoSource: '', file: {} })
    //             }
    //         }

    //         return false
    //     })
}

//Finally not used in chat
export async function uploadFile(attachment, storageRef, showProgress) {

    this.uploadTask = storageRef.putFile(attachment.path)

    const promise = new Promise((resolve, reject) => {
        this.uploadTask.on('state_changed', async function (tasksnapshot) {
            var progress = Math.round((tasksnapshot.bytesTransferred / tasksnapshot.totalBytes) * 100)
            console.log('Upload attachment ' + progress + '% done')

            if (showProgress) {
                attachment.progress = progress / 100
                this.setState({ attachment })
            }

            // switch (tasksnapshot.state) {
            //     case firebase.storage.TaskState.PAUSED: // or 'paused'
            //         console.log('Upload is paused')
            //         break
            //     case firebase.storage.TaskState.RUNNING: // or 'running'
            //         console.log('Upload is running')
            //         break
            // }

        }.bind(this))

        //#task: can be canceled

        this.uploadTask.then(async (res) => {
            attachment.downloadURL = await storageRef.getDownloadURL()
            attachment.generation = 'upload' //possible values: ['upload', 'sign', 'app']      upload: uploaded by user; sign: generated after signature; app: pdf generated by app
            delete attachment.progress
            this.setState({ attachment }, () => resolve(attachment))
        })
            .catch(err => {
                attachment.progress = 0
                this.setState({ attachment })
                reject('failure')
            })
    })

    return promise
}

export async function uploadFileNew(attachment, storageRefPath, DocumentId, rehydrated) { //#task: add showProgress as param

    console.log('3. uploadOfflineBeta')
    console.log('3.1 attachment', attachment)
    console.log('3.2 storageRefPath', storageRefPath)
    console.log('3.3 DocumentId', DocumentId)
    console.log('3.4 rehydrated', rehydrated)

    const promise = new Promise(async (resolve, reject) => {

        const storageRef = firebase.storage().ref(storageRefPath)
        const uploadTask = storageRef.putFile(attachment.path)

        var payload = { ...attachment }
        payload.DocumentId = DocumentId
        payload.storageRefPath = storageRefPath

        if (!rehydrated) {
            await onUploadProgressStart(this, payload)
        }

        uploadTask
            .on('state_changed', async function (tasksnapshot) {
                var progress = Math.round((tasksnapshot.bytesTransferred / tasksnapshot.totalBytes) * 100)
                console.log('Upload attachment ' + progress + '% done')

                //dispatch action to update attachment progress with id = DocumentId
                payload.progress = progress / 100
                onUploadProgressChange(this, payload)

            }.bind(this))

        uploadTask
            .then(async (res) => {
                attachment.downloadURL = await storageRef.getDownloadURL()
                attachment.generation = 'upload'
                attachment.pending = false
                delete attachment.progress

                db.collection('Documents').doc(DocumentId).update({ attachment })
                onUploadProgressEnd(this, payload)
            })
            .catch((e) => {
                console.error('upload error', e)
                console.log('Removing attachment from document with Id: ', DocumentId)

                db.collection('Documents').doc(DocumentId).update({ attachment: null })
                onUploadProgressEnd(this, payload)
            })
    })

    return Promise
}